% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ffbs.R
\name{ffbs}
\alias{ffbs}
\title{Use bridged sampling to impute a complete dive trajectory consistent with observations}
\usage{
ffbs(Bt, O, W, lambda, shift.scale = 0)
}
\arguments{
\item{lambda}{length 3 vector that specifies the transition rate, 
respectively in the DIVING, SUBMERGED, and SURFACING stages.}

\item{M}{the number of trajectories to sample}

\item{depth.bins}{\eqn{n x 2} Matrix that defines the depth bins.  The first 
column defines the depth at the center of each depth bin, and the second 
column defines the half-width of each bin.}

\item{depths}{record of depth bins the trajectory should visit}

\item{times}{times at which the depth bins should be visited}

\item{s0}{dive stage at which the trajectory should be started from}

\item{beta}{\eqn{2 x 3} matrix in which each column contains the diving 
preference and directional persistence parameters for the DIVING, SUBMERGED, 
and SURFACING dive stages.}

\item{sub.tx}{length 2 vector that specifies the first depth bin at which 
transitions to the SUBMERGED stage can occur and the probability that such 
a transition occurs at the next depth transition}

\item{surf.tx}{parameter that specifies the probability the trajectory will 
transition to the SURFACING stage at the next depth transition}

\item{inflation.factor.lambda}{In order to facilitate bridged transitions, 
the transition rate of the overall process must be inflated to allow the 
possibility of self-transitions.  Self-transitions allow bridged paths to 
dynamically modify the total number of transitions between observed values
so that a valid path between observations is always possible.  The 
\code{inflation.factor.lambda} parameter implicitly controls the number of 
self-transitions that will occur.  Larger values will create more 
self-transitions.}

\item{verbose}{If \code{TRUE}, then the sampler's progress will be printed 
during sampling.}

\item{precompute.bridges}{If \code{TRUE}, then the bridged transition 
matrices will be precomputed.  Enabling this option will increase the 
memory overhead of the method, but will reduce its runtime.}

\item{t0.dive}{Time at which dive started}

\item{resample}{Resample particles at each step if \code{TRUE}.}

\item{trajectory.conditional}{If not \code{NULL}, then 
\code{trajectory.conditional} must be the dive information for a 
completely observed \code{dsdive} object.  The first entries in the 
initialization vectors \code{d0}, \code{d0.last}, \code{s0} must be 
associated with the trajectory observed in \code{trajectory.conditional}.
Providing a non \code{NULL} value for \code{trajectory.conditional} will 
cause \code{dsdive.fastbridge} to simulate one fewer trajectories, as 
the value of \code{trajectory.conditional} will be returned.  The 
importance of this function argument is that \code{dsdive.fastbridge}
will evaluate the proposal density for \code{trajectory.conditional}.}

\item{model}{Either \code{"conditional"} or \code{"logit"} depending on the 
method used to determine stage transition probability curves}

\item{ld.compute}{\code{TRUE} to compute likelihood values as well.  This 
is required if resampling or conditional trajectory imputation is used.}

\item{t.stages}{the times at which stage transitions occur}
}
\description{
The sampling method is designed to sample many trajectories simultaneously, 
so has an extra level of approximation in the proposal distributions.
}
\examples{
devtools::document()

# construct transition matrix
# B = matrix(runif(100), nrow = 10, ncol = 10)
B = matrix(0, nrow = 30000, ncol = 30000)
diag(B) = 4
diag(B[,-1]) = 1
diag(B[-1,]) = 1
B = B / rowSums(B)

library(Matrix)
library(spam)

B = as.dgCMatrix.spam(as.spam(B))


# set initial conditions
init = 1

# set number of transitions to make
t = 20

# forward sample transitions
s = numeric(t)
s[1] = init
for(i in 2:t) {
  s[i] = sample(x = 1:nrow(B), size = 1, prob = B[s[i-1],])
}

# observe process at some indices
na.inds = sample(x = 2:(t-1), size = .5*t)
O = s
O[na.inds] = NA

# wrap transition matrices
Bt = vector('list', t)
for(i in 1:t) {
  Bt[[i]] = B
}

devtools::document()
# draw from posterior
x = t(replicate(1e3, ffbs(Bt = Bt, O = O)))

# verify sampling reproduces observations
all(t(x[,!is.na(O)]) == O[!is.na(O)])


#
# check some posterior distributions of missing values
#

ind = which(is.na(O))[9]
table(x[,ind])/sum(table(x[,ind]))
s[ind]
}

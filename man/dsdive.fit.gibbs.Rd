% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dsdive.fit.gibbs.R
\name{dsdive.fit.gibbs}
\alias{dsdive.fit.gibbs}
\title{Gibbs sampler to approximate posterior for model parameters}
\usage{
dsdive.fit.gibbs(depths, times, durations = NULL, stages = NULL,
  depth.bins, t0.dive, it, verbose = FALSE,
  inflation.factor.lambda = 1.1, init, sigma = NULL, priors.sd,
  priors.mean, adapt = c(100, 20, 0.5, 0.75), state.backup = list(t =
  Inf, file = "state.RData"), scale.sigma.init = 1)
}
\arguments{
\item{depths}{record of depth bins the trajectory should visit}

\item{times}{times at which the depth bins should be visited}

\item{depth.bins}{\eqn{n x 2} Matrix that defines the depth bins.  The first 
column defines the depth at the center of each depth bin, and the second 
column defines the half-width of each bin.}

\item{t0.dive}{Time at which dive started}

\item{verbose}{If \code{TRUE}, then the sampler's progress will be printed 
during sampling.}

\item{inflation.factor.lambda}{In order to facilitate bridged transitions, 
the transition rate of the overall process must be inflated to allow the 
possibility of self-transitions.  Self-transitions allow bridged paths to 
dynamically modify the total number of transitions between observed values
so that a valid path between observations is always possible.  The 
\code{inflation.factor.lambda} parameter implicitly controls the number of 
self-transitions that will occur.  Larger values will create more 
self-transitions.}

\item{init}{List of parameter values at which to initialize the MCMC chain}

\item{sigma}{List of covariance matrices for block-Random walk proposals.
First entry in list should be covariance matrix for depth transition 
parameters, and second entry in list should be covariance matrix for 
rate and stage transition parameters.}

\item{priors.sd}{vector of standard deviations for model parameters on their 
respective transformed scales}

\item{state.backup}{If not \code{NULL}, then a list that specifies a file 
to which the sampler state will be dumped every \code{t} seconds.}

\item{scale.sigma.init}{Amount by which to scale the initial proposal 
covariance matrices}

\item{s0}{dive stage at which the trajectory should be started from}

\item{beta}{\eqn{2 x 3} matrix in which each column contains the diving 
preference and directional persistence parameters for the DIVING, SUBMERGED, 
and SURFACING dive stages.}

\item{lambda}{length 3 vector that specifies the transition rate, 
respectively in the DIVING, SUBMERGED, and SURFACING stages.}

\item{sub.tx}{length 2 vector that specifies the first depth bin at which 
transitions to the SUBMERGED stage can occur and the probability that such 
a transition occurs at the next depth transition}

\item{surf.tx}{parameter that specifies the probability the trajectory will 
transition to the SURFACING stage at the next depth transition}

\item{precompute.bridges}{If \code{TRUE}, then the bridged transition 
matrices will be precomputed.  Enabling this option will increase the 
memory overhead of the method, but will reduce its runtime.}
}
\description{
The code is designed to approximate posterior distributions when the dive 
trajectory is either completely or incompletely observed.  When the 
trajectory is incompletely observed, a latent dive trajectory will be updated 
using an independence proposal at each iteration.
}
\examples{
data('dive.sim')
attach(dive.sim)
attach(dive.sim$params)

x = dsdive.fit.gibbs(depths = sim.obs$depths, times = sim.obs$times, 
                     durations = NULL, stages = NULL, depth.bins = depth.bins, 
                     t0.dive = sim.obs$times[1], it = 50, verbose = TRUE, 
                     init = params, priors.sd = rep(1,12), 
                     priors.mean = rep(0, 12))

detach(dive.sim$params)
detach(dive.sim)
}

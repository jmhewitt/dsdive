% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dsdive.obsld_approx.R
\name{dsdive.obsld_approx}
\alias{dsdive.obsld_approx}
\title{Likelihood for collection of partially observed dives}
\usage{
dsdive.obsld_approx(
  dsobs.list,
  t.stages.list,
  s0,
  sf,
  beta,
  lambda,
  P.interpolator
)
}
\arguments{
\item{dsobs.list}{list of \code{dsobs} objects, which describe the 
observation times and depths of a collection of dives}

\item{t.stages.list}{list of stage transition times for dives 
observed in \code{dsobs.list}}

\item{s0}{likelihood should include contributions for stages greater or 
equal to \code{s0}}

\item{sf}{likelihood should include contributions for stages less than or 
equal to \code{sf}}

\item{beta}{vector with directional preference parameters for descent and
ascent stages.}

\item{lambda}{vector with dive rate parameters for the descent, bottom, and 
ascent stages.}

\item{P.interpolator}{list of functions to approximate transition 
probabilities in a given stage, given model parameters, and a timestep}
}
\description{
Likelihood for collection of partially observed dives
}
\examples{
data('dive.sim')
attach(dive.sim)
attach(dive.sim$params)

library(parallel)


#
# build interpolating functions
#

cl = makeCluster(spec = 3, type = 'SOCK')
clusterEvalQ(cl, library(dsdive))

interpolators = lapply(1:3, function(s0) {
  
  # support for directional preferences, speeds, and timesteps
  if(s0 == 1) {
    beta.seq = seq(.5, 1, length.out = 7)
    beta.seq[length(beta.seq)] = .999
    lambda.seq = seq(.1, 2, length.out = 7)
    tstep.seq = seq(0, 300, by = 100)
  } else if(s0 == 2) {
    beta.seq = .5
    lambda.seq = seq(.1, 2, length.out = 7)
    tstep.seq = seq(0, 300, by = 100)
  } else if(s0 == 3) {
    beta.seq = seq(0, .5, length.out = 7)
    beta.seq[1] = 1-.999
    lambda.seq = seq(.1, 2, length.out = 7)
    tstep.seq = seq(0, 300, by = 100)
  }
  
  interpolators = dsdive.obstx.matrix_interpolator(
    depth.bins = depth.bins, beta.seq = beta.seq, lambda.seq = lambda.seq,
    s0 = s0, tstep.seq = tstep.seq, m = 3, verbose = TRUE, cl = cl)
  
})

stopCluster(cl = cl)

# get true stage transition times
t.stages = sim$times[c(FALSE, diff(sim$stages)==1)]

# compute likelihood of observations, given model parameters
ld = dsdive.obsld_approx(dsobs.list = list(sim.obs,sim.obs),
                         t.stages.list = list(t.stages,t.stages), 
                         s0 = 1, sf = 3, beta = params$beta, 
                         lambda = params$lambda, P.interpolator = interpolators)

detach(dive.sim$params)
detach(dive.sim)
}

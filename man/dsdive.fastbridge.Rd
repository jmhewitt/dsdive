% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dsdive.fastbridge.R
\name{dsdive.fastbridge}
\alias{dsdive.fastbridge}
\title{Impute a family of dive trajectories that meet start and end times}
\usage{
dsdive.fastbridge(M, depth.bins, d0, d0.last, df, beta, lambda, sub.tx,
  surf.tx, t0, tf, s0, inflation.factor.lambda = 1.1, verbose = FALSE,
  precompute.bridges = TRUE, lambda.max = NULL, t0.dive,
  trajectory.conditional = NULL, t.stage2)
}
\arguments{
\item{M}{the number of trajectories to sample}

\item{depth.bins}{\eqn{n x 2} Matrix that defines the depth bins.  The first 
column defines the depth at the center of each depth bin, and the second 
column defines the half-width of each bin.}

\item{d0}{the depth bin at which the trajectory begins}

\item{d0.last}{the depth bin from which the trajectory entered \code{d0}.
Set \code{d0=NULL} if the trajectory is beginning at the surface depth bin.}

\item{df}{the depth bin at which the trajectory should end}

\item{beta}{\eqn{2 x 3} matrix in which each column contains the diving 
preference and directional persistence parameters for the DIVING, SUBMERGED, 
and SURFACING dive stages.}

\item{lambda}{length 3 vector that specifies the transition rate, 
respectively in the DIVING, SUBMERGED, and SURFACING stages.}

\item{sub.tx}{length 2 vector that specifies the first depth bin at which 
transitions to the SUBMERGED stage can occur and the probability that such 
a transition occurs at the next depth transition}

\item{surf.tx}{parameter that specifies the probability the trajectory will 
transition to the SURFACING stage at the next depth transition}

\item{t0}{time at which the trajectory should start}

\item{tf}{time at which the trajectory should end}

\item{s0}{dive stage in which the trajectory begins}

\item{inflation.factor.lambda}{In order to facilitate bridged transitions, 
the transition rate of the overall process must be inflated to allow the 
possibility of self-transitions.  Self-transitions allow bridged paths to 
dynamically modify the total number of transitions between observed values
so that a valid path between observations is always possible.  The 
\code{inflation.factor.lambda} parameter implicitly controls the number of 
self-transitions that will occur.  Larger values will create more 
self-transitions.}

\item{verbose}{If \code{TRUE}, then the sampler's progress will be printed 
during sampling.}

\item{lambda.max}{Arrival rate for the parent Poisson process that will
be thinned.  \code{lambda.max} will be scaled by 
\code{inflation.factor.lambda}, and if \code{lambda.max==NULL} then the 
method will compute this on its own.}

\item{t0.dive}{Time at which dive started}

\item{trajectory.conditional}{If not \code{NULL}, then 
\code{trajectory.conditional} must be the dive information for a 
completely observed \code{dsdive} object.  The first entries in the 
initialization vectors \code{d0.last} and \code{s0} must be 
associated with the trajectory observed in \code{trajectory.conditional}.
Providing a non \code{NULL} value for \code{trajectory.conditional} will 
cause \code{dsdive.fastbridge} to simulate one fewer trajectories, as 
the value of \code{trajectory.conditional} will be returned.  The 
importance of this function argument is that \code{dsdive.fastbridge}
will evaluate the proposal density for \code{trajectory.conditional}.}

\item{t.stage2}{vector of times at which stage 2 was entered.}
}
\description{
Sample a dive trajectory such that its start and end locations and times are 
fixed.  Sampling uses a thinned Poisson process and bridged Markov chain 
transition probabilities.  Sampling is not from the model's theoretical 
imputation distribution, but an approximation thereof.  The trajectory's
log-density is returned with the output.
}
\details{
The sampling method is designed to sample many trajectories simultaneously, 
so has an extra level of approximation in the proposal distributions.
}
\examples{
data('dive.sim')
attach(dive.sim)
attach(params)

br = dsdive.fastbridge(M = 1e2, depth.bins = depth.bins, d0 = sim.obs$depths[1], 
                       d0.last = NULL, df = sim.obs$depths[2], beta = beta, 
                       lambda = lambda, sub.tx = sub.tx, surf.tx = surf.tx, 
                       t0 = sim.obs$times[1], tf = sim.obs$times[2], s0 = 1,
                       verbose = TRUE, t0.dive = 0, t.stage2 = NA)

detach(params)
detach(dive.sim)
}

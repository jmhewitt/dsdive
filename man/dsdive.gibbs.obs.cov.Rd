% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dsdive.gibbs.obs.cov.R
\name{dsdive.gibbs.obs.cov}
\alias{dsdive.gibbs.obs.cov}
\title{Gibbs sampler for parameters of a model for dives across discrete depth bins}
\usage{
dsdive.gibbs.obs.cov(
  dsobs.list,
  covs,
  t.stages.list,
  beta.init,
  alpha.init,
  verbose = FALSE,
  maxit,
  checkpoint.fn,
  checkpoint.interval = 3600,
  beta1.prior,
  beta2.prior,
  alpha1.prior,
  alpha2.prior,
  alpha3.prior,
  tstep,
  depth.bins,
  T1.prior.params,
  T2.prior.params,
  max.width,
  max.width.offset,
  t0.prior.params,
  tf.prior.params,
  offsets,
  offsets.tf,
  cl,
  pi.formula,
  lambda.formula,
  warmup = Inf,
  delta = 1e-10,
  optim.maxit = 1000,
  adaptive = FALSE,
  adaptation.frequency = 10
)
}
\arguments{
\item{dsobs.list}{list of \code{dsobs} objects, which describe the
observation times and depths of a collection of dives}

\item{covs}{matrix of covariates associated with \code{dsobs.list}.  Each
row ov \code{covs} should contain all covariates for a single dive.}

\item{t.stages.list}{list of initial stage transition times for dives
observed in \code{dsobs.list}}

\item{beta.init}{Initial values for directional preference model parameters.
See \code{dsdive.tx.params} for more details.  Should be a list, in which
each component contains the initial value for coefficients for
logit(pi^{(s)}.)}

\item{alpha.init}{Initial values for diving rate model parameters.  See
\code{dsdive.tx.params} for more details.  Should be a list, in which
each component contains the initial value for coefficients for
log(lambda^{(s)}).}

\item{verbose}{\code{TRUE} to output sampler status while running}

\item{maxit}{number of Gibbs iterations to run}

\item{checkpoint.fn}{User-defined function to run during a checkpoint step;
gives the user an opportunity to save partial output from the sampler}

\item{checkpoint.interval}{Number of seconds between calls to
\code{checkpoint.fn}}

\item{beta1.prior}{List containing \code{mean} and \code{sd} parameters for
independent Normal prior distributions on the coefficients for the
dive-stage model parameter \eqn{\pi^{(1)}}.  The length of the \code{mean}
and \code{sd} vectors should be equal to the number of coefficients for
this model component.}

\item{beta2.prior}{List containing \code{mean} and \code{sd} parameters for
independent Normal prior distributions on the coefficients for the
dive-stage model parameter \eqn{\pi^{(3)}}.  The length of the \code{mean}
and \code{sd} vectors should be equal to the number of coefficients for
this model component.}

\item{alpha1.prior}{List containing \code{mean} and \code{sd} parameters for
independent Normal prior distributions on the coefficients for the
dive-stage model parameter \eqn{\lambda^{(1)}}.  The length of the
\code{mean} and \code{sd} vectors should be equal to the number of
coefficients for this model component.}

\item{alpha2.prior}{List containing \code{mean} and \code{sd} parameters for
independent Normal prior distributions on the coefficients for the
dive-stage model parameter \eqn{\lambda^{(2)}}.  The length of the
\code{mean} and \code{sd} vectors should be equal to the number of
coefficients for this model component.}

\item{alpha3.prior}{List containing \code{mean} and \code{sd} parameters for
independent Normal prior distributions on the coefficients for the
dive-stage model parameter \eqn{\lambda^{(3)}}.  The length of the
\code{mean} and \code{sd} vectors should be equal to the number of
coefficients for this model component.}

\item{tstep}{Time between observations in \code{dsobs.list}}

\item{depth.bins}{\eqn{n x 2} Matrix that defines the depth bins.  The first
column defines the depth at the center of each depth bin, and the second
column defines the half-width of each bin.}

\item{T1.prior.params}{\code{shape} and \code{rate} parameters for Gamma
prior on the descent-stage duration.}

\item{T2.prior.params}{\code{shape} and \code{rate} parameters for Gamma
prior on the bottom-stage duration.}

\item{max.width}{The stage transition times are updated with a piecewise
proposal distribution.  \code{max.width} controls the maximum width of the
intervals for the proposal distribution.  This is a tuning parameter that
controls the numerical stability of the proposal distribution, which is
sampled via inverse CDF techniques.}

\item{max.width.offset}{The t0 and tf offsets are updated with a piecewise
proposal distribution.  \code{max.width.offset} controls the maximum width
of the intervals for the proposal distribution.  This is a tuning parameter
that controls the numerical stability of the proposal distribution, which
is sampled via inverse CDF techniques.}

\item{t0.prior.params}{\code{shape1} and \code{shape2} parameters for the
scaled and shifted Beta prior distribution for the t0 offset.}

\item{tf.prior.params}{\code{shape1} and \code{shape2} parameters for the
scaled and shifted Beta prior distribution for the tf offset.}

\item{offsets}{vector with initial values for t0 offsets.}

\item{offsets.tf}{vector with initial values for tf offsets.}

\item{cl}{Shared-memory cluster to be used to distribute some computations.
The cluster must be fully initialized before running this function.
The cluster requires random seeds and \code{Rdsm}-initialization.}

\item{pi.formula}{List of formula objects, each of which defines the linear
model that combines covariates in the \code{covs} matrix into
dive-specific diving preferences logit(pi^{(s)}).}

\item{lambda.formula}{List of formula objects, each of which defines the
linear model that combines covariates in the \code{covs} matrix into
dive-specific diving rates log(lambda^{(s)}).}

\item{warmup}{number of iterations during which the proposal distributions 
will be updated at each step}

\item{delta}{If \code{delta>0}, then the observation matrix and raw 
components computed will be for a transition matrix whose generator is 
perturbed to allow much faster computation.}

\item{optim.maxit}{maximum number of steps to take during numerical 
optimization to compute Gaussian approximation to full conditional 
posteriors used to propose model parameters}

\item{adaptive}{\code{TRUE} to use adaptive Random walk Metropolis-Hastings 
samplers to update model parameters instead of Gaussian approximations to 
the full conditional posteriors.}

\item{adaptation.frequency}{Random walk proposals will only be updated 
at intervals of this step count}
}
\description{
This function differs from \code{dsdive.gibbs.obs} in that this function
allows the model to be estimated with dive-specific covariates.
}
\examples{
data('dive.sim')
attach(dive.sim)
attach(dive.sim$params)
library(parallel)
library(Rdsm)

cl = makeCluster(2, 'SOCK')
clusterEvalQ(cl, library(dsdive))
clusterEvalQ(cl, library(Rdsm))

mgrinit(cl)

t.stages = sim$times[c(FALSE,diff(sim$stages)==1)]
  
tstep = diff(sim.obs$times[1:2])

obstx.mat = lapply(1:3, function(s) {
  dsdive.obstx.matrix(depth.bins = depth.bins, beta = beta, 
                      lambda = lambda, s0 = s, tstep = tstep, 
                      include.raw = TRUE, delta = 1e-10)
})

lambda.priors = list(
  list(mu = 0, sd = 3),
  list(mu = 0, sd = 3),
  list(mu = 0, sd = 3)
)

beta.priors = list(
  list(mu = 0, sd = 3),
  list(mu = 0, sd = 3)
)

T1.prior.params = c(25, .04)
T2.prior.params = c(56, .06)

dsobs.list = list(sim.obs, sim.obs)
t.stages.list = list(t.stages, t.stages)

beta.init = list(
  c(qlogis(.5), 0),
  c(0, 1)
)

alpha.init = c(beta.init, list(c(-1,-1)))

covs = data.frame(x1 = c(.5, 1), x2 = c(0, .3))

pi.formula = ~x1
lambda.formula = ~x1:x2

fit = dsdive.gibbs.obs.cov(
  dsobs.list = dsobs.list, t.stages.list = t.stages.list, 
  beta.init = beta.init, alpha.init = alpha.init, verbose = TRUE, maxit = 1, 
  beta1.prior = beta.priors[[1]], beta2.prior = beta.priors[[2]], 
  alpha1.prior = lambda.priors[[1]], alpha2.prior = lambda.priors[[2]], 
  alpha3.prior = lambda.priors[[3]], tstep = tstep, depth.bins = depth.bins, 
  T1.prior.params = T1.prior.params, T2.prior.params = T2.prior.params, 
  max.width = 100, max.width.offset = 30, t0.prior.params = c(1,1), 
  tf.prior.params = c(1,1), offsets = 0, offsets.tf = 0, warmup = 1, 
  covs = covs, pi.formula = pi.formula,  lambda.formula = lambda.formula, 
  cl = cl, optim.maxit = 1, delta = 1e-10)


detach(dive.sim$params)
detach(dive.sim)

stopCluster(cl)

}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dsdive.fwdsample.R
\name{dsdive.fwdsample}
\alias{dsdive.fwdsample}
\title{Simulate dive trajectories across discrete depth bins}
\usage{
dsdive.fwdsample(depths.labels, d0, beta, lambda, sub.tx, surf.tx, t0, tf,
  steps.max, dur0 = NULL, nsteps = NULL)
}
\arguments{
\item{depths.labels}{character vector that defines the depth bins}

\item{d0}{the depth bin at which transition parameters should be computed}

\item{beta}{\eqn{2 x 3} matrix in which each column contains the diving 
preference and directional persistence parameters for the DIVING, SUBMERGED, 
and SURFACING dive stages.}

\item{lambda}{length 3 vector that specifies the transition rate, 
respectively in the DIVING, SUBMERGED, and SURFACING stages.}

\item{sub.tx}{length 2 vector that specifies the first depth bin at which 
transitions to the SUBMERGED stage can occur and the probability that such 
a transition occurs at the next depth transition}

\item{surf.tx}{parameter that specifies the probability the trajectory will 
transition to the SURFACING stage at the next depth transition}

\item{t0}{time at which transition parameters should be computed}

\item{tf}{time at which sampling should end after}

\item{steps.max}{maximum number of transitions to sample before stopping, 
regardless of whether \code{tf} is reached.}

\item{dur0}{time spent at location \code{d0}.  If \code{NULL}, then a 
duration in state \code{d0} will be sampled, otherwise a new state will 
be sampled first, then sampling will continue from the new state at time 
\code{t0 + dur0}.}
}
\value{
A \code{dsdive} object, which is a \code{list} with the following 
  vectors:
  \describe{
    \item{depths}{Record of which depth bins the trajectory visited}
    \item{durations}{Record of amount of time spent in each depth bin}
    \item{times}{The time at which each depth bin was entered}
    \item{stages}{The stage at which each depth bin was entered}
  }
}
\description{
The method will simulate dive trajectories from initial conditions until the 
trajectory is observable at \code{tf}, or a maximum number of transitions 
has been exceeded.  The dive simulation is bridged, so the trajectory will
also stop diving after returning to the surface.
}
\examples{
# define depth domain
max.depths = seq(from = 0, to = 1e3, by = 5)
num.depths = length(max.depths)

# define transition parameters
beta = matrix(c(2.5,   0, -1.5, 
                -.5, -.5, -.75), 
              nrow = 2, byrow = TRUE)
lambda = 1/c(3, 3, 3)
sub.tx = c(50, .02)
surf.tx = 5e-3

#
# explore transition parameters
#

dsdive.tx.params(t0 = 0, num.depths = num.depths, d0 = 0, d0.last = NULL, 
                 s0 = 1, beta = beta, lambda = lambda, sub.tx = sub.tx, 
                 surf.tx = surf.tx)

dsdive.tx.params(t0 = 0, num.depths = num.depths, d0 = 60, d0.last = 61, 
                 s0 = 1, beta = beta, lambda = lambda, sub.tx = sub.tx, 
                 surf.tx = surf.tx)

dsdive.tx.params(t0 = 0, num.depths = num.depths, d0 = 60, d0.last = 61, s0 = 2, 
                 beta = beta, lambda = lambda, sub.tx = sub.tx, 
                 surf.tx = surf.tx)

#
# simulate and observe a dive
#

# simulate dive
x = dsdive.fwdsample(depths.labels = max.depths, d0 = 0, beta = beta, 
                     lambda = lambda, sub.tx = sub.tx, surf.tx = surf.tx, 
                     t0 = 0, tf = Inf, steps.max = 1e5, dur0 = NULL, 
                     nsteps = NULL)

# observe dive at regular time intervals
obs = dsdive.observe(depths = x$depths, times = x$times, 
                     t.obs = seq(from = 0, to = max(x$times), by = 1*60))

#
# summarize and plot dive
#

library(dplyr)
library(ggplot2)
library(ggthemes)

x.df = x
class(x.df) = 'list'
x.df = data.frame(x.df) \%>\% mutate(min = times/60,
                                   min.start = min,
                                   min.end = min + durations/60, 
                                   p.min = max.depths[depths + 1],
                                   p.max = max.depths[depths + 2])

obs.df = data.frame(obs) \%>\% mutate(min = times/60,
                                    p = max.depths[depths+1] + 
                                        .5 * (max.depths[depths+2] - 
                                              max.depths[depths+1]))
                                      
# time spent in each dive stage
x.df \%>\% 
  group_by(stages) \%>\% 
  filter(!is.na(durations)) \%>\%
  summarise(total.mins = sum(durations)/60)

# plot dive
ggplot(x.df, aes(x=min, y=p.max)) + 
  # plot trajectory
  geom_rect(mapping = aes(xmin = min.start, xmax = min.end, 
                          ymin = p.min, ymax = p.max,
                          fill = factor(stages))) + 
  # plot subsampled trajectory
  geom_vline(xintercept = obs.df$min, lty = 3, col = 'grey80') + 
  geom_point(mapping = aes(x=min, y=p), inherit.aes = FALSE, data = obs.df,
             pch = 18) + 
  # formatting
  scale_fill_brewer('Dive stage', type = 'qual', palette = 'Set2') + 
  scale_y_reverse() + 
  xlab('Time (min)') + 
  ylab('Depth (m)') + 
  theme_few() + 
  theme(panel.border = element_blank(),
        legend.position = 'top')
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dsdive.impute.R
\name{dsdive.impute}
\alias{dsdive.impute}
\title{Use bridged sampling to impute a complete dive trajectory consistent with observations}
\usage{
dsdive.impute(depths, times, t.stages, rate.unif, P.raw, P.tx, n.bins, max.tx)
}
\arguments{
\item{depths}{record of depth bins the trajectory should visit}

\item{times}{times at which the depth bins should be visited}

\item{t.stages}{the times at which stage transitions occur}

\item{M}{the number of trajectories to sample}

\item{depth.bins}{\eqn{n x 2} Matrix that defines the depth bins.  The first 
column defines the depth at the center of each depth bin, and the second 
column defines the half-width of each bin.}

\item{s0}{dive stage at which the trajectory should be started from}

\item{beta}{\eqn{2 x 3} matrix in which each column contains the diving 
preference and directional persistence parameters for the DIVING, SUBMERGED, 
and SURFACING dive stages.}

\item{lambda}{length 3 vector that specifies the transition rate, 
respectively in the DIVING, SUBMERGED, and SURFACING stages.}

\item{sub.tx}{length 2 vector that specifies the first depth bin at which 
transitions to the SUBMERGED stage can occur and the probability that such 
a transition occurs at the next depth transition}

\item{surf.tx}{parameter that specifies the probability the trajectory will 
transition to the SURFACING stage at the next depth transition}

\item{inflation.factor.lambda}{In order to facilitate bridged transitions, 
the transition rate of the overall process must be inflated to allow the 
possibility of self-transitions.  Self-transitions allow bridged paths to 
dynamically modify the total number of transitions between observed values
so that a valid path between observations is always possible.  The 
\code{inflation.factor.lambda} parameter implicitly controls the number of 
self-transitions that will occur.  Larger values will create more 
self-transitions.}

\item{verbose}{If \code{TRUE}, then the sampler's progress will be printed 
during sampling.}

\item{precompute.bridges}{If \code{TRUE}, then the bridged transition 
matrices will be precomputed.  Enabling this option will increase the 
memory overhead of the method, but will reduce its runtime.}

\item{t0.dive}{Time at which dive started}

\item{resample}{Resample particles at each step if \code{TRUE}.}

\item{trajectory.conditional}{If not \code{NULL}, then 
\code{trajectory.conditional} must be the dive information for a 
completely observed \code{dsdive} object.  The first entries in the 
initialization vectors \code{d0}, \code{d0.last}, \code{s0} must be 
associated with the trajectory observed in \code{trajectory.conditional}.
Providing a non \code{NULL} value for \code{trajectory.conditional} will 
cause \code{dsdive.fastbridge} to simulate one fewer trajectories, as 
the value of \code{trajectory.conditional} will be returned.  The 
importance of this function argument is that \code{dsdive.fastbridge}
will evaluate the proposal density for \code{trajectory.conditional}.}

\item{model}{Either \code{"conditional"} or \code{"logit"} depending on the 
method used to determine stage transition probability curves}

\item{ld.compute}{\code{TRUE} to compute likelihood values as well.  This 
is required if resampling or conditional trajectory imputation is used.}
}
\description{
The sampling method is designed to sample many trajectories simultaneously, 
so has an extra level of approximation in the proposal distributions.
}
\examples{
data('dive.sim')
attach(dive.sim)
attach(dive.sim$params)

# true stage transition times for the dive
t.stages = sim$times[c(FALSE, diff(sim$stages)==1)]

# uniformized transition rate
rate.unif = max(outer(lambda, 2*depth.bins[,2], '/'))

# time between observations
tstep = diff(sim.obs$times[1:2])

# probability transition matrix for observations
P.raw = lapply(1:3, function(s) {
  dsdive.obstx.matrix(depth.bins = depth.bins, beta = beta, 
                      lambda = lambda, s0 = s, tstep = tstep, 
                      include.raw = TRUE)
})

# probability transition matrix for uniformized DTMC
P.tx = lapply(1:3, function(s) {
  dsdive.tx.matrix.uniformized(depth.bins = depth.bins, beta = beta, 
                               lambda = lambda, s0 = s, 
                               rate.uniformized = rate.unif)
})

# impute dive trajectory
x = dsdive.impute(
  depths = sim.obs$depths, times = sim.obs$times, t.stages = t.stages, 
  rate.unif = rate.unif, P.raw = P.raw, P.tx = P.tx, n.bins = nrow(depth.bins), 
  max.tx = 100)

# overlay trajectory over observations
pl = plot(x = sim.obs, depth.bins = depth.bins, stages = sim.obs$stages, 
          errorbars = TRUE, imputed.list = x)

detach(dive.sim$params)
detach(dive.sim)
}

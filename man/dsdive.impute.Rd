% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dsdive.impute.R
\name{dsdive.impute}
\alias{dsdive.impute}
\title{Impute a complete dive trajectory from partial observations}
\usage{
dsdive.impute(
  depths,
  times,
  t.stages,
  rate.unif,
  P.raw,
  P.tx,
  n.bins = nrow(depths),
  max.tx
)
}
\arguments{
\item{depths}{Depth bin indices visited}

\item{times}{Times at which each of \code{depths} was visited}

\item{t.stages}{Stage transition times for the dive; will be used to compute
the dive stage for each observation}

\item{rate.unif}{uniformization rate, for standardizing transition
rates between states}

\item{P.raw}{list of continuous time probability transition matrices, and 
components.}

\item{P.tx}{list of discrete time probability transition matrices}

\item{n.bins}{number of rows in the \code{depths} matrix}

\item{max.tx}{maximum number of transitions between observations that will 
be allowed during imputation}
}
\description{
Uses properties of homogeneous Continuous time Markov Chains (CTMCs) to 
impute trajectory segments between observations.  The sampler begins by 
sampling the number of transitions between observations \eqn{N}, then 
samples a length \code{N} path that connects the trajectory segment at its 
start and end states.
}
\examples{
data('dive.sim')
attach(dive.sim)
attach(dive.sim$params)

# true stage transition times for the dive
t.stages = sim$times[c(FALSE, diff(sim$stages)==1)]

# uniformized transition rate
rate.unif = max(outer(lambda, 2*depth.bins[,2], '/'))

# time between observations
tstep = diff(sim.obs$times[1:2])

# probability transition matrix for observations
P.raw = lapply(1:3, function(s) {
  dsdive.obstx.matrix(depth.bins = depth.bins, beta = beta, 
                      lambda = lambda, s0 = s, tstep = tstep, 
                      include.raw = TRUE)
})

# probability transition matrix for uniformized DTMC
P.tx = lapply(1:3, function(s) {
  dsdive.tx.matrix.uniformized(depth.bins = depth.bins, beta = beta, 
                               lambda = lambda, s0 = s, 
                               rate.uniformized = rate.unif)
})

# impute dive trajectory
x = dsdive.impute(
  depths = sim.obs$depths, times = sim.obs$times, t.stages = t.stages, 
  rate.unif = rate.unif, P.raw = P.raw, P.tx = P.tx, n.bins = nrow(depth.bins), 
  max.tx = 100)

# overlay trajectory over observations
pl = plot(x = sim.obs, depth.bins = depth.bins, stages = sim.obs$stages, 
          errorbars = TRUE, imputed.list = x)

detach(dive.sim$params)
detach(dive.sim)
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dsdive.impute_segments.R
\name{dsdive.impute_segments}
\alias{dsdive.impute_segments}
\title{Impute a sequence of dive segments from a fixed transition matrix}
\usage{
dsdive.impute_segments(
  depth.bins,
  depths,
  times,
  beta,
  lambda,
  s0,
  inflation.factor.lambda = 1.1,
  verbose = FALSE,
  method.N = "exact",
  N.max = NULL,
  t.sbreaks = NULL,
  truncpois.scale = 0.8
)
}
\arguments{
\item{depth.bins}{\eqn{n x 2} Matrix that defines the depth bins.  The first
column defines the depth at the center of each depth bin, and the second
column defines the half-width of each bin.}

\item{beta}{\eqn{2 x 3} matrix in which each column contains the diving
preference and directional persistence parameters for the DIVING, SUBMERGED,
and SURFACING dive stages.}

\item{lambda}{length 3 vector that specifies the transition rate,
respectively in the DIVING, SUBMERGED, and SURFACING stages.}

\item{s0}{dive stage in which the trajectory begins}

\item{inflation.factor.lambda}{In order to facilitate bridged transitions,
the transition rate of the overall process must be inflated to allow the
possibility of self-transitions.  Self-transitions allow bridged paths to
dynamically modify the total number of transitions between observed values
so that a valid path between observations is always possible.  The
\code{inflation.factor.lambda} parameter implicitly controls the number of
self-transitions that will occur.  Larger values will create more
self-transitions.}

\item{verbose}{If \code{TRUE}, then the sampler's progress will be printed
during sampling.}

\item{M}{the number of trajectories to sample}

\item{d0}{the depth bin at which the trajectory begins}

\item{d0.last}{the depth bin from which the trajectory entered \code{d0}.
Set \code{d0=NULL} if the trajectory is beginning at the surface depth bin.}

\item{df}{the depth bin at which the trajectory should end}

\item{sub.tx}{length 2 vector that specifies the first depth bin at which
transitions to the SUBMERGED stage can occur and the probability that such
a transition occurs at the next depth transition}

\item{surf.tx}{parameter that specifies the probability the trajectory will
transition to the SURFACING stage at the next depth transition}

\item{t0}{time at which the trajectory should start}

\item{tf}{time at which the trajectory should end}

\item{lambda.max}{Arrival rate for the parent Poisson process that will
be thinned.  \code{lambda.max} will be scaled by
\code{inflation.factor.lambda}, and if \code{lambda.max==NULL} then the
method will compute this on its own.}

\item{t0.dive}{Time at which dive started}

\item{trajectory.conditional}{If not \code{NULL}, then
\code{trajectory.conditional} must be the dive information for a
completely observed \code{dsdive} object.  The first entries in the
initialization vectors \code{d0.last} and \code{s0} must be
associated with the trajectory observed in \code{trajectory.conditional}.
Providing a non \code{NULL} value for \code{trajectory.conditional} will
cause \code{dsdive.fastbridge} to simulate one fewer trajectories, as
the value of \code{trajectory.conditional} will be returned.  The
importance of this function argument is that \code{dsdive.fastbridge}
will evaluate the proposal density for \code{trajectory.conditional}.}

\item{t.stage2}{vector of times at which stage 2 was entered.}

\item{model}{Either \code{"conditional"} or \code{"logit"} depending on the
method used to determine stage transition probability curves}

\item{ld.compute}{\code{TRUE} to compute likelihood values as well.}
}
\description{
Impute a sequence of dive segments from a fixed transition matrix
}
\examples{
data('dive.sim')
attach(dive.sim)
attach(dive.sim$params)

t.sbreaks = sim$times[c(FALSE, diff(sim$stages)==1)]

x = dsdive.impute_segments(depth.bins = depth.bins, 
                           depths = sim.obs$depths, 
                           times = sim.obs$times, beta = beta, 
                           lambda = lambda, s0 = 1, 
                           inflation.factor.lambda = 1.1, 
                           method.N = 'truncpois', N.max = 100, 
                           t.sbreaks = t.sbreaks )

pl = plot(x = sim.obs, depth.bins = depth.bins, stages = sim.obs$stages, 
          errorbars = TRUE, imputed.list = x, imputed.alpha = .6)

detach(dive.sim$params)
detach(dive.sim)
}
